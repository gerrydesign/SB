package com.apps{	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	import fl.transitions.easing.*;	import com.greensock.*;	import com.greensock.easing.*;	import flash.display.Shape;	/**	* ...	* @author Ady Levy	*/	public class Scroller extends Sprite	{		// const values :		private const MIN_FACE_SIZE:int = 25; // minimum scroller face size		private const MOUSE_WHEEL_PRECENTAGE:Number = 0.15; // when scrolling with wheel		private var gap:int = -6; // gap from pane				public var ScrollerPane:Sprite; // the pane		private var PaneMask:Sprite; // our mask		public var ScrollerFace:Sprite; // our scroller						/*		 * scroller constructor :		 * pane - your pane to add a scroller to		 * w,h - width and height of scrolling area		 * facemc - Sprite to attach as a scroller face		 * align - in the future i'll add a vertical scroller to the class (too lazy)		 * */		function Scroller(pane:Sprite, w:int, h:int,FaceMC:Sprite,align:String, color:uint, g:int = -6, pname:String = "panemask", sc:String =  "scroll"):void		{						//trace("PANE HEIGHT:::::::::::::::::::::::::" + pane.height)			//trace("H:::::::::::::::::::::::::" + h)			ScrollerPane = pane;			ScrollerFace = FaceMC;			colorize(ScrollerFace, color)			//ScrollerFace = createScruber()			ScrollerFace.name = sc;			PaneMask = createMask(w, h);			PaneMask.name = pname;			PaneMask.x = ScrollerPane.x;			PaneMask.y = ScrollerPane.y;			pane.parent.addChild(PaneMask);			pane.mask = PaneMask;			gap = g;												// adds the mouse wheel handler to the pane :			//ScrollerPane.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelHandler);						createScroller(ScrollerPane,w,h,ScrollerFace,align);						//createScruber()		}				public function empty():void{			ScrollerPane.mask = null;			//ScrollerPane =  null;			}					public function resetSize(newHeight:int):void{			var FaceSize = (PaneMask.height / newHeight) * PaneMask.height ;				if (FaceSize > newHeight){				TweenLite.to(ScrollerFace, .5, {autoAlpha:0, visible: false});				trace("new height::::::::::::::::::::::::" +  newHeight)				}else{				TweenLite.to(ScrollerFace, .5, {autoAlpha:1, visible: true});				}			TweenMax.to(ScrollerFace, .5, {height:FaceSize});		}				/*	 * attach the scroller face and defines its behaviour.	 * */	private function createScroller(ScrollerPane, w:int, h:int, FaceMC:Sprite, align) {		trace(":::::::::::::createScroller::::::::::::");		trace(":::::::::::::createScroller::::::::::::");		trace(":::::::::::::createScroller::::::::::::");		trace(":::::::::::::createScroller::::::::::::");		trace(":::::::::::::createScroller::::::::::::");		trace("ScrollerPane.height::::::::::::::::::::::::::::::::" + ScrollerPane.height);		trace("h::::::::::::::::::::::::::::::::" + h);		trace(":::::::::::::createScroller::::::::::::");		trace(":::::::::::::createScroller::::::::::::");		if(ScrollerPane.height > h)		{		FaceMC.visible = true;		TweenLite.to(FaceMC, .5, { visible:true, autoAlpha:1 , ease:Regular.easeOut } );		//trace('scroller created');		}else {		TweenLite.to(FaceMC, .5, { visible:false, autoAlpha:0 , ease:Regular.easeOut } );				//trace("scroller not needed")		}					FaceMC.alpha = 0;				ScrollerPane.parent.addChild(FaceMC);		FaceMC.x = ScrollerPane.x + w + gap;		FaceMC.y = ScrollerPane.y;		var FaceSize = (PaneMask.height / ScrollerPane.height) * PaneMask.height ;		if (FaceSize>MIN_FACE_SIZE) FaceMC.height = FaceSize;				FaceMC.buttonMode = true;		FaceMC.addEventListener(MouseEvent.MOUSE_DOWN,ScrollFaceDown)		FaceMC.addEventListener(MouseEvent.MOUSE_UP, ScrollFaceUp)							}					 /** i am using the stage for mouse up event and mouse move, 	 * because it behaves better.	 *	private function StageMouseUP(event:*)	{		ScrollFaceUp(event);	}	 */	/*	 * mouse down handler	 * */	private function ScrollFaceDown(event:*)	{		ScrollerPane.stage.addEventListener(MouseEvent.MOUSE_UP, ScrollFaceUp);		ScrollerPane.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);				var bounds:Rectangle = new Rectangle(PaneMask.x+PaneMask.width+gap, PaneMask.y, 0 , PaneMask.height-ScrollerFace.height);				ScrollerFace.startDrag(false,bounds);		}		/*	 * mouse up handler	 * */	private function ScrollFaceUp(event:*)	{		ScrollerPane.stage.removeEventListener(MouseEvent.MOUSE_UP, ScrollFaceUp);		ScrollerPane.stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);		ScrollerFace.stopDrag();		}		/*	 * this function updates the pane position according to the scroller position	 * */	private function updatePanePosition()	{		var precentage = (ScrollerFace.y- PaneMask.y)/ ( PaneMask.height - ScrollerFace.height);		var myMovingArea = ScrollerPane.height - PaneMask.height;		var moveTo = myMovingArea * precentage;				TweenLite.to(ScrollerPane, .6, { y:PaneMask.y - moveTo, ease:Regular.easeOut} );			}		private function mouseMoveHandler(event:*)	{		updatePanePosition();	}		/*	 * mouse wheel rolled on the pane	 * here delta can be -6,-3,3,6 ..	 * according to the scrolling speed	 * i just scroll up and down, you can use the -6/-3 behaviour if you like	 * 	 * */	private function mouseWheelHandler(event:*)	{						var moveMent = MOUSE_WHEEL_PRECENTAGE * (PaneMask.y + PaneMask.height - ScrollerFace.height);		var newPos:int;		if (event.delta > 0) 			newPos = Math.max(ScrollerFace.y - moveMent,PaneMask.y);		else			newPos = Math.min (ScrollerFace.y + moveMent,PaneMask.y + PaneMask.height - ScrollerFace.height);					TweenLite.to(ScrollerFace, .6, { y:newPos, ease:Regular.easeOut } );				var precentage = (newPos- PaneMask.y) / ( PaneMask.height - ScrollerFace.height);		var myMovingArea = ScrollerPane.height - PaneMask.height;		var moveTo = myMovingArea * precentage;		TweenLite.to(ScrollerPane, .2, { y:PaneMask.y - moveTo, ease:Regular.easeOut } );					}		/*	 * create the pane mask	 * */	private function createMask(panelW, panelH):Sprite	{		var cont:Sprite = new Sprite();		var color = Math.round(Math.random()*0xFFFFFF);		cont.graphics.beginFill(color,0.5);		cont.graphics.drawRect(0,0,panelW,panelH);		cont.graphics.endFill();		return cont;	}		private function colorize(s:Sprite, tint:uint):void{		TweenMax.to(s, .5, {colorMatrixFilter:{colorize:tint, amount:1}, dropShadowFilter:{color:0x000000, alpha:0.5, blurX:8, blurY:8, strength:0.5, angle:180, distance:0}} );	}		private function createScruber():void	{						/*var my_shape:Sprite = new Sprite();						//my_shape.graphics.lineStyle(.1, 0xFF0000, 1);		my_shape.graphics.beginFill(0xFFFFFF,1)		my_shape.graphics.moveTo(14, 0);		my_shape.graphics.lineTo(14, 100);		my_shape.graphics.curveTo(0,100, 0,90);		my_shape.graphics.lineTo(0, 14);		my_shape.graphics.curveTo(0,0, 14,0);		my_shape.graphics.endFill();				var lineDrawing:Sprite = new Sprite;		lineDrawing.graphics.lineStyle(.1,0x000000);		lineDrawing.graphics.moveTo(3,50); ///This is where we start drawing		//lineDrawing.graphics.lineTo(3, 50);		lineDrawing.graphics.lineTo(12, 50);				var lineDrawing1:Sprite = new Sprite;		lineDrawing1.graphics.lineStyle(.1,0xffffff);		lineDrawing1.graphics.moveTo(3,51); ///This is where we start drawing		lineDrawing1.graphics.lineTo(12, 51);		//lineDrawing1.graphics.lineTo(12, 51);				my_shape.addChild(lineDrawing);		my_shape.addChild(lineDrawing1);								var grid:Rectangle = new Rectangle(2, 14, 10, 72);		my_shape.scale9Grid = grid;*/				//return my_shape;	}		}}